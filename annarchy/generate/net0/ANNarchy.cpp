
#include "ANNarchy.h"


/*
 * Internal data
 *
 */
double dt;
long int t;
std::mt19937  rng;

// Custom constants


// Populations
PopStruct0 pop0;
PopStruct1 pop1;
PopStruct2 pop2;
PopStruct3 pop3;


// Projections
ProjStruct0 proj0;
ProjStruct1 proj1;
ProjStruct2 proj2;


// Global operations


// Recorders
std::vector<Monitor*> recorders;
void addRecorder(Monitor* recorder){
    recorders.push_back(recorder);
}
void removeRecorder(Monitor* recorder){
    for(int i=0; i<recorders.size(); i++){
        if(recorders[i] == recorder){
            recorders.erase(recorders.begin()+i);
            break;
        }
    }
}

void singleStep(); // Function prototype

// Simulate the network for the given number of steps,
// called from python
void run(int nbSteps) {

    for(int i=0; i<nbSteps; i++) {
        singleStep();
    }

}

// Simulate the network for a single steps,
// called from python
void step() {

    singleStep();

}

int run_until(int steps, std::vector<int> populations, bool or_and)
{


    run(steps);
    return steps;


}

// Initialize the internal data and the random numbers generator
void initialize(double _dt, long int seed) {


    // Internal variables
    dt = _dt;
    t = (long int)(0);

    // Random number generators
    setSeed(seed);

    // Populations
    // Initialize populations
    pop0.init_population();
    pop1.init_population();
    pop2.init_population();
    pop3.init_population();


    // Projections
    // Initialize projections
    proj0.init_projection();
    proj1.init_projection();
    proj2.init_projection();


    // Custom constants


}

// Initialize the random distribution objects
void init_rng_dist() {
pop0.init_rng_dist();
pop1.init_rng_dist();
pop2.init_rng_dist();
pop3.init_rng_dist();

}

// Change the seed of the RNG
void setSeed(long int seed){
    if(seed==-1){
        rng = std::mt19937(time(NULL));
    }
    else{
        rng = std::mt19937(seed);
    }
}

// Step method. Generated by ANNarchy.
void singleStep()
{


    ////////////////////////////////
    // Presynaptic events
    ////////////////////////////////


    proj0.compute_psp();
    proj1.compute_psp();
    proj2.compute_psp();



    ////////////////////////////////
    // Recording target variables
    ////////////////////////////////
    for(int i=0; i < recorders.size(); i++){
        recorders[i]->record_targets();
    }

    ////////////////////////////////
    // Update random distributions
    ////////////////////////////////




    ////////////////////////////////
    // Update neural variables
    ////////////////////////////////

    pop0.update();
    pop1.update();
    pop2.update();
    pop3.update();



    ////////////////////////////////
    // Delay outputs
    ////////////////////////////////


    ////////////////////////////////
    // Global operations (min/max/mean)
    ////////////////////////////////


    ////////////////////////////////
    // Update synaptic variables
    ////////////////////////////////

    proj2.update_synapse();



    ////////////////////////////////
    // Postsynaptic events
    ////////////////////////////////


    ////////////////////////////////
    // Structural plasticity
    ////////////////////////////////


    ////////////////////////////////
    // Recording neural / synaptic variables
    ////////////////////////////////

    for(int i=0; i < recorders.size(); i++){
        recorders[i]->record();
    }


    ////////////////////////////////
    // Increase internal time
    ////////////////////////////////
    t++;


}


/*
 * Access to time and dt
 *
*/
long int getTime() {return t;}
void setTime(long int t_) { t=t_;}
double getDt() { return dt;}
void setDt(double dt_) { dt=dt_;}

/*
 * Number of threads
 *
*/
void setNumberThreads(int threads)
{
    
}
